# https://leetcode.com/problems/kth-smallest-amount-with-single-denomination-combination/description/

from typing import List
from itertools import combinations, chain
from math import lcm, ceil, gcd
from functools import reduce

"""
We will apply binary search not on position based but on value based
At each step try to find the value & proceed ahead
"""


def find_lcm(a, b):
    return abs(a * b) // gcd(a, b)


def calc_lcm(*nums):
    return reduce(find_lcm, nums)


def get_all_comb(coins):
    combs = chain.from_iterable(
        combinations(coins, i) for i in range(1, len(coins) + 1)
    )
    return list(combs)


def inclusion_exclusion(kit):
    has_odd_length = len(kit) & 1
    return 1 if has_odd_length else -1


def find_pos_insequence(val, kits):
    """find position of {val} in sequence generated by {kits} s.t.
    return value
     - will denotes the position of [val] if [val] is valid number of sequence
     - will denotes the position of valid value on left to [val] of sequence
    """
    cardinality = 0  # total elements behind in sequenece
    for kit in kits:
        start = calc_lcm(*kit)
        # position of [val] in sequence generated by [start] S.T. (start * i) <= val
        # {pos} will be leftmost position of valid candidate to [val] if [val] is not valid candidate
        pos = val // start
        cardinality += inclusion_exclusion(kit) * pos
    return cardinality


class Solution:
    def findKthSmallest(self, coins: List[int], k: int) -> int:
        upper_k = 2 * 10**9
        all_combs = get_all_comb(coins)

        l = 1  # first value in sequence
        # eqn = a + (n-1) * d
        r = 25 + ((upper_k - 1) * 25)  # possible last value in sequence (in worst case)

        res = 1
        # As we need to validate individual element as well so kept l <= r & not l < r
        while l <= r:
            amt = (l + r) // 2
            pos = find_pos_insequence(amt, all_combs)

            if pos < k:
                l = amt + 1
            else:
                # look for more smaller value because its not ensured that [amt] is actually part of a sequence
                r = amt - 1
                res = amt

        return res


# nums = [1, 3, 5]
# print(get_all_comb(nums))
